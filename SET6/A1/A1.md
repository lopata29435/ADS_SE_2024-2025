pandoc your_file.md -o output.pdf --pdf-engine=xelatex

## ALG_1

### Описание алгоритма:
1) Сортируем ребра графа в порядке невозрастания весов.
2) Инициализируем множество $T$ всеми ребрами графа.
3) Последовательно удаляем ребра из $T$, если их удаление не нарушает связность графа.

### Структуры данных и временная сложность:

- Сортировка ребер: $O(|E| \log |E|)$

- Проверка связности графа после удаления ребра: Используем структуру данных UnionFind, которая позволяет эффективно проверять связность и объединять множества. Проверка связности и объединение выполняются за $O(\alpha(∣V∣))$, где $\alpha$ — обратная функция Аккермана (очень медленно растущая функция, практически константа).

- Общая сложность: $O(∣E∣ \log ∣E∣ + ∣E∣⋅\alpha(∣V∣))$, очевидно, что останется только $O(∣E∣ \log ∣E∣)$

### Реализация на C++:

```C++
#include <algorithm>
#include <vector>
#include <unordered_set>
#include "UnionFind.h"

struct Edge {
    int u, v, weight;
    bool operator<(const Edge& other) const {
        return weight > other.weight;
    }
};

std::vector<Edge> ALG_1(const std::vector<Edge>& edges, int n) {
    std::vector<Edge> sortedEdges = edges;
    std::sort(sortedEdges.begin(), sortedEdges.end());

    UnionFind uf(n);
    std::vector<Edge> T = sortedEdges;

    for (const Edge& e : sortedEdges) {
        uf.unite(e.u, e.v);
        if (uf.components() == 1) {
            break;
        }
    }

    return T;
}
```

### Построит ли минимальное остовное дерево?
- По индукции:
    1) **База индукции**:  
   На входе алгоритм получает связный граф \( G \), который содержит хотя бы одно минимальное остовное дерево (MST) \( T \). Это очевидно, так как любое связное множество рёбер, соединяющее все вершины, содержит некоторое MST.

    2) **Шаг индукции**:  
    Рассмотрим промежуточный этап работы алгоритма, когда мы удаляем ребро \( e \):

    - **Если удалённое ребро \( e \) не принадлежало MST \( T \)**, то его удаление не влияет на минимальное остовное дерево, и корректность сохраняется.
    
    - **Если удалённое ребро \( e \) принадлежало MST \( T \)**:  
        Так как алгоритм не нарушает связность, это означает, что в исходном графе существовал цикл, содержащий \( e \).  
        После удаления \( e \) множество рёбер \( T \) становится несвязным, разделяя его на два подграфа \( T_1 \) и \( T_2 \).  
        Однако, поскольку граф \( G \) связен, между \( T_1 \) и \( T_2 \) существует хотя бы одно другое ребро, соединяющее их.  
        Это ребро либо имеет такой же вес, либо меньший (иначе \( T \) изначально не был бы MST).  
        Если бы это другое ребро имело больший вес, алгоритм уже бы удалил его раньше, а значит, оно минимально возможное.  

    В итоге множество рёбер \( T - e + e' \) также образует MST, и корректность алгоритма сохраняется на каждом шаге.  
    Таким образом, по индукции, итоговый результат алгоритма — минимальное остовное дерево.

### Пример 
$V$ = {0,1,2}

$E$ = {(0,1,1), (1,2,2), (0,2,3)}

Сортировка:
$E$ = (0,2,3), (1,2,2), (0,1,1)

Множество $T$:
$T$ = {(0,2,3), (1,2,2), (0,1,1)}


- Удаляем (0,2,3).  
  Граф остаётся связным.  
  $T$ = {(1,2,2), (0,1,1)}.  

- Удаляем (1,2,2).  
  - Граф становится несвязным.  
  - Возвращаем (1,2,12) в $T$.  

Конец

Итог:
T = {(0,1,1), (1,2,2)}

## ALG_2

### Описание алгоритма:
1) Инициализируем пустое множество $T$.
2) Случайным образом добавляем ребра в $T$, если они не образуют цикл.

### Структуры данных и временная сложность:

- Проверка на цикл: $O(\alpha(∣V∣))$, т.к мы всё также используем просто UnionFind для проверки связанности и циклов.

- Общая сложность: $O(∣E∣⋅\alpha(∣V∣))$, т.к это нам придется сделать для каждого ребра.

### Реализация на C++:

```C++
#include <algorithm>
#include <vector>
#include <unordered_set>
#include "UnionFind.h"

//я предпологаю что у нас есть функция, которая шафлит перед запуском наш массив ребер :)
std::vector<Edge> ALG_2(const std::vector<Edge>& edges, int n) {
    UnionFind uf(n);
    std::vector<Edge> T;

    for (const Edge& e : edges) {
        if (uf.find(e.u) != uf.find(e.v)) {
            uf.unite(e.u, e.v);
            T.push_back(e);
        }
    }

    return T;
}
```

### Построит ли минимальное остовное дерево?

### Контр пример: 

- у нас есть граф на трех вершинах (треугольник) у которого две стороны равны по 1 и одна 2. Получается что минимальное остовное дерево можно построить взяв два ребра по 1, но алгоритм может взять ребра 1 и 2 и тогда это не будет минимальное остовное дерево, ч.т.д

## ALG_3

### Описание алгоритма:
1) Инициализируем пустое множество $T$.
2) Случайным образом добавляем ребра в $T$.
3) Если в $T$ образуется цикл, удаляем ребро с максимальным весом из этого цикла.

### Структуры данных и временная сложность:

- Добавление ребра во множество $T$ - $O(\alpha(∣V∣))$, всё также выполняется с помощью UnionFind.

- Проверка наличия цикла - $O(\alpha(∣V∣))$, всё также выполняется с помощью UnionFind.

- Поиск максимального ребра в цикле - $O(E)$. В теории можно добавить какую-то динамическую структуру данных, которая будет автоматически находить нам минимальное ребро, но это звучит сильно сложно, но гипотетически возможно и я даже могу предположить такую структуру (Link Cut tree), но это вне рамок курса, так что не считается, но мы  рассмотрим, у него асимптотика $O(\log(E))$.

- Удаление максимального ребра - если использовать LCT, то $\log(E)$, елси обычный массив, то $O(1)$

- Итоговая сложность - в худшем случае мы пройдем по всем ребрам и выполним операции UnionFind и операцию удаления и поиска, а за. В таком случае для LCT: $O(E * (\alpha(V) + \log(V) ) ) => O(E(\log(V)))$, для обычного массива $O(E * (\alpha(V) + V ) ) => O(E * V)$*()



### Реализация на C++:

```C++
#include <algorithm>
#include <vector>
#include <unordered_set>
#include "UnionFind.h"

struct Edge {
    int u, v, weight;
    bool operator<(const Edge& other) const {
        return weight > other.weight;
    }
};

//всё также предпологаючто нам дается зашафленный массив :)
vector<Edge> ALG_3(int V, vector<Edge> &edges) {
    vector<Edge> T;
    UnionFind uf(V);

    for (const Edge &e : edges) {
        T.push_back(e);
        if (!uf.unite(e.u, e.v)) {
            auto it = max_element(T.begin(), T.end(), [](const Edge &a, const Edge &b) {
                return a.weight < b.weight;
            });
            T.erase(it);
        }
    }
    return T;
}
```

### Построит ли минимальное остовное дерево?

- Если исходный граф уже является деревом, то очевидно (MST).
- Если в графе есть циклы, алгоритм уберет из цикла самое тяжелое => что цикл будет построен из наименьших возможных ребер
- Если в итоговом дереве остаётся какое-то тяжёлое ребро, можно рассмотреть два случая
    1) Оно никогда не участвовало в цикле => значит, оно действительно необходимо для связности и должно входить в MST.

    2) Оно было частью цикла, но алгоритм удалил другое ребро => удалённое ребро было тяжелее, а оставшееся не нарушает минимальность остовного дерева.
- Поскольку каждое добавление рёбра может образовать не более одного цикла, то при его обнаружении всегда удаляется ровно одно (самое тяжёлое) ребро. Это гарантирует сохранение связности и минимальности.

### Пример
$V$ = {0, 1, 2, 3, 4}

Рёбра в формате $(u, v, w)$, где $(u,w)$ - ребро, $w - вес$

$E$ = (0,1,3),(1,2,1),(2,3,4),(3,4,2),(0,4,5),(1,3,6)

добавляем ребра в таком порядке:
1) $T$ = {(0, 4, 5)}
2) $T$ = {(0, 4, 5), (1, 3, 6)}
3) $T$ = {(0, 4, 5), (1, 3, 6), (0, 1, 3)}
4) $T$ = {(0, 4, 5), (1, 3, 6), (0, 1, 3), (1, 2, 1)}
5) $T$ = {(0, 4, 5), (1, 3, 6), (0, 1, 3), (1, 2, 1), (2, 3, 4) - это ребро образует цикл 1->2->3->1, удаляем самое тяжелое в цикле, то есть (1, 3, 6)}
   
   $T$ = {(0, 4, 5), (0, 1, 3), (1, 2, 1), (2, 3, 4)}
6) $T$ = {(0, 4, 5), (0, 1, 3), (1, 2, 1), (2, 3, 4), (3, 4, 2 )}
    Опять цикл 0->4->3->2->1->0, удаляем самое тяжелое:
    $T$ = {(0,1,3),(1,2,1),(2,3,4),(3,4,2)} 

Итак мы получили MST
