## Модификация алгоритма Дейкстры для произведения весов рёбер

В случае, когда длина пути определяется как произведение весов рёбер, алгоритм Дейкстры изменяется следующим образом:

### Инициализация:

- Устанавливаем расстояние до стартовой вершины: `dist[start] = 1` (так как произведение весов для пути из вершины в саму себя равно 1).
- Для всех остальных вершин: `dist[v] = ∞` (или очень большое число).

### Основной цикл:

1. На каждом шаге выбираем вершину `u` с минимальным значением `dist[u]`.
2. Для каждого соседа `v` вершины `u` обновляем расстояние:
   - `dist[v] = min(dist[v], dist[u] × w(u, v))`, где `w(u, v)` — вес ребра между вершинами `u` и `v`.
3. Повторяем процесс до тех пор, пока все вершины не будут обработаны.

### Корректность алгоритма:

- Алгоритм будет работать корректно только для графов с положительными весами рёбер. Это связано с тем, что произведение положительных чисел сохраняет свойство монотонности, необходимое для работы алгоритма Дейкстры(жалность).
- Если в графе присутствуют нулевые или отрицательные веса рёбер, то произведение может стать нулевым или отрицательным, что нарушит принцип жадного выбора и сделает алгоритм некорректным.

### Примеры:

- **Граф с положительными весами**: алгоритм работает корректно.
- **Граф с отрицательными весами**: алгоритм может дать некорректные результаты, так как произведение отрицательных весов может уменьшить длину пути, что нарушает принцип жадного выбора.

```C++
#include <iostream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

struct Edge {
    int v;
    double weight;
};

void dijkstraMod(int start, int n, vector<vector<Edge>>& graph) {
    vector<double> dist(n, INT_MAX);
    dist[start] = 1;

    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq;
    pq.push({1, start});

    while (!pq.empty()) {
        double d = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        if (d > dist[u]) continue;

        for (const Edge& e : graph[u]) {
            int v = e.v;
            double weight = e.weight;

            double newDist = dist[u] * weight;

            if (newDist < dist[v]) {
                dist[v] = newDist;
                pq.push({newDist, v});
            }
        }
    }

    for (int i = 0; i < n; ++i) {
        if (dist[i] == INT_MAX)
            cout << "До вершины " << i << " нельзя добраться" << endl;
        else
            cout << "Расстояние до вершины " << i << ": " << dist[i] << endl;
    }
}
```

## RestoreGraph(dist[][])

1. Создаём пустой список смежности для графа G.
2. Для каждой пары вершин проверяем значение `dist[i][j]`:
   - Если `dist[i][j] ≠ ∞`, восстанавливаем ребро между вершинами `i` и `j` с весом `dist[i][j]`.
   - Если для некоторых `k` выполняется условие `dist[i][k] + dist[k][j] = dist[i][j]`, то не добавляем новое ребро, так как это может указывать на наличие кратчайшего пути через промежуточную вершину `k`.

### Проблемы при восстановлении графа:

1. **Нарушение неравенства треугольника**:
   - Если для некоторых вершин `i`, `j` и `k` выполняется условие `dist[i][j] > dist[i][k] + dist[k][j]`, это означает, что матрица расстояний не соответствует никакому графу. Такое несоответствие может быть вызвано ошибками в вычислениях или некорректными данными.

2. **Нулевые расстояния для `i ≠ j`**:
   - Если `dist[i][j] = 0` для `i ≠ j`, это нарушает условие, что расстояние между различными вершинами должно быть положительным. Такой случай указывает на ошибку в данных или структуре графа.

3. **Отрицательные циклы**:
   - Если граф содержит отрицательные циклы, то кратчайшие пути могут не существовать, и восстановление графа становится невозможным.

4. **Неоднозначность восстановления графа**:
   - Восстановление графа может быть неоднозначныи. Например, если для пары вершин существует несколько путей с одинаковым весом, то алгоритм может выбрать один из них. Пример: если в графе есть ребра `(0,1,5)`, `(1,2,4)`, и `(0,2,9)`, то `dist[0][2]` будет равно 9, и когда мы восстанавливаем граф, мы можем не добавить ребро `(0,2)`, так как существует альтернативный путь через вершину 1 с тем же весом.

```C++
#include <iostream>
#include <vector>
#include <limits>

using namespace std;

const int INF = 1e9;

struct Edge {
    int target;
    int weight;

    Edge(int t, int w) : target(t), weight(w) {}
};

void RestoreGraph(const vector<vector<int>>& dist) {
    int n = dist.size();
    vector<vector<Edge>> adj(n);

    for (int u = 0; u < n; ++u) {
        for (int v = 0; v < n; ++v) {
            if (dist[u][v] == INF || u == v) continue;

            bool isDirectEdge = true;

            for (int k = 0; k < n; ++k) {
                if (k == u || k == v || dist[u][k] == INF || dist[k][v] == INF) {
                    continue;
                }

                if (dist[u][k] * dist[k][v] == dist[u][v]) {
                    isDirectEdge = false;
                    break;
                }
            }

            if (isDirectEdge) {
                adj[u].emplace_back(v, dist[u][v]);
            }
        }
    }

    for (int u = 0; u < adj.size(); ++u) {
        cout << u << ": ";
        for (const auto& edge : adj[u]) {
            cout << edge.target << " " << edge.weight;
        }
        cout << '\n';
    }
}
```

## Алгоритм Флойда-Уоршелла. Ошибка

### 
Ошибка в приведённой реализации алгоритма Флойда-Уоршелла заключается в неправильном порядке обхода индексов `i`, `j` и `k`. В классической реализации алгоритма Флойда-Уоршелла внешний цикл должен быть по `k` (промежуточная вершина), а внутренние циклы — по `i` и `j` (начальная и конечная вершины). Это связано с тем, что на каждом шаге алгоритм рассматривает возможность улучшения пути между вершинами `i` и `j` через промежуточную вершину `k`.

###
Пример можно найти в этом коде:
```Python
def floyd_warshall_wrong(dist):
    n = len(dist)
    for i in range(n):
        for j in range(n):
            for k in range(n):
                if  (i != j):
                    if dist[i][k] + dist[k][j] < dist[i][j]:    
                        dist[i][j] = dist[i][k] + dist[k][j]
                    
def floyd_warshall_correct(dist):
    n = len(dist)
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] != 1e9 and dist[k][j] != 1e9:
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])


n = 3

dist_error = [
    [0,   1,   1e9, 1e9],
    [1e9, 0,   1,   1e9],
    [1e9, 1e9, 0,   1],
    [1,   1e9, 1e9, 0]
]

dist_correct = [
    [0,   1,   1e9, 1e9],
    [1e9, 0,   1,   1e9],
    [1e9, 1e9, 0,   1],
    [1,   1e9, 1e9, 0]
]

floyd_warshall_wrong(dist_error)
print(dist_error)
floyd_warshall_correct(dist_correct)
print(dist_correct)
```
Вывод(верхняя строка неправильный алгоритм, нижняя строка правильный):
```
[[0, 1, 2, 3], [1000000000.0, 0, 1, 2], [2, 3, 0, 1], [1, 2, 3, 0]]
[[0, 1, 2, 3], [3, 0, 1, 2], [2, 3, 0, 1], [1, 2, 3, 0]]
```

## Существует ли такой граф?
### Характеристика графа:

- Граф ориентированный и взвешенный.
- Он симметричен в том смысле, что содержит пути, позволяющие двигаться как от **a** к **b**, так и от **b** к **a**, проходя через одни и те же промежуточные вершины **vᵢ** и **vⱼ**.
- Граф содержит циклы, например:
  - **a → vᵢ → vⱼ → a**
  - **b → vᵢ → vⱼ → b**
- Все веса рёбер положительные, что делает граф пригодным для алгоритмов, требующих неотрицательных весов, таких как алгоритм Дейкстры.

### Ограничения применимости алгоритмов

- Если в графе появятся отрицательные веса или отрицательные циклы, алгоритм Дейкстры перестанет быть применимым.
- В таких случаях потребуется использование алгоритмов Флойда-Уоршелла или Беллмана-Форда, которые требуют дополнительной проверки на наличие отрицательных циклов.

Таким образом, описанный граф возможен, но его свойства накладывают определенные ограничения на применимость алгоритмов поиска кратчайших путей в зависимости от весов рёбер.

### Пример

```
--1--
|   |
a→1→v_i→1→v_j→1→b
    |           |
    ------1------
```

min из a в b: `a → v_c → v_i → b` с весом 3.

min из b в a: `b → v_i → v_j → a` с весом 3.